
Erläuterungen zu dem Modul PaintLimiterModul und der Klasse PaintLimiterClass.

Windows ist nicht dafür geeignet Animationen gleichmäßig und flüssig darzustellen.
Um das zu erreichen muß man tief in die Trickkiste greifen - dazu sind diese beiden
PainterLimiter zuständig.

Der Grund für den Aufwand ist die (technisch bedingte) Unzuverlässigkeit des Timers
bei sehr kurzen Zeiten. Überlagert wird das noch davon, das das Paint Event nach dem
Befehl Me.Invalidate nicht sofort ausgelößt wird, sondern erst dann, wenn es dem
Betriebssystem passt. Die Bildschirmausgabe steht in der Rangordnung ziemlich weit
unten.

Gelößt wird das im Prinzip wie folgt:

STOPP, STOP,das war mein erster Ansatz, der nicht funktioniert, weil Windows nicht
davon abzuhalten ist, das Zeichnen komplett abzugeben, obwohl die entsprechenden
Flags gesetzt waren.
1a.) Ein Timer lößt viel zu oft das Me.Invalidate aus, im Abstand von nur einer 
    Millisekunden. Windows verarbeitet die nicht alle, verwirft die Meisten gleich.
    Aber es kommen so viele durch, daß das Maximum erreicht wird.

2a.) Im Paint Event der Oberfläche, auf die gezeichnet werden soll (Also UCtlSpielfeld
    und UCtlEditor) kommen jetzt viel zu viele Paint-Events an.
    Daher wird als erstes geprüft, ob überhaupt gezeichnet werden darf:

        Private Sub UCtlSpielfeld_Paint(sender As Object, e As PaintEventArgs) Handles Me.Paint
            
            If Spielfeld.PaintLimiter.BeginPaint Then
                Spielfeld.PaintSpielfeld_Paint(frmMain.VisibleUserControl.Spielfeld, e, New Rectangle(0, 0, Width, Height), Spielfeld.PaintLimiter.TimeDifferenzFaktor)
            End If

        End Sub

1b.) Paint-Events, die ankommen, werden immer gezeichnet.

2b.) Die Auslösung des Invalidate im UserControl wird vom einem Timer getaktet,
     (schneller als notwendig) die Taktrate aber von einer Stopwatch überprüft
     und erst nach Ablauf einer Mindestzeit wird Invalidate aus gelößt. 

3.) PaintSpielfeld wird noch der Wert FrameScheduler.TimeDifferenzFaktor mitgegeben.
    Das ist ein Faktor, der angibt um wieviel sich das Event gegenüber der Sollzeit
    verspätet (oder verfrüht) hat. Damit kann die Animation korrigiert werden,
    z.B. die Anpassung des Drehwinkels zwischen zwei Frames, sodaß der Eindruck der
    Gleichmäßigkeit entsteht. 
    Damit läßt sich nicht alles kaschieren, aber es ist deutlich besser als eine
    konventionelle Steuerung.

    Zum RenderTimer.Interval:
        ' 10–15ms ist gut,  = 1 ergibt einen etwas stabileren Takt von 15 ms,
        ' hat aber Auswirkung auf alle Timer im System und kostet mehr Energie.
        ' Werte über 30 verlangsamen die Geschwindigkeit, was zu einer Vergröberung
        ' der Animation führt. (Die Gesamtlänge der Animation bleibt, die Schritte
        ' werde größer, bis es irgendwann kippt und die Anumationsdauer sich verlängert.) 
        ' Der Wert läßt sich in der Basis.ini Folder: Spielfeld, Key: RenderTimerInterval
        ' ändern. 

In frmMain ist noch etwas Verwaltungsarbeit notwendig.

Im Designer ist auf FrmMain ein TabControl zu sehen, mit je einem Reiter je Usercontrol.
Sobald das Programm läuft, verschwindet das Tabcontrol.
Die einzelnen UserControls werden über das Menue nach Bedarf in frmMain "eingehängt".

Das Einhängen geschieht in  Private Property AktVisibleUserControl As VisibleUserControl
im Setter. Hier gibt es folgenden Abschnitt:

    'Ein eventuell noch laufendes Spielfeld abschalten
    
    Spielfeld.PaintSpielfeld_CancelGeneralPermission()

    'Und das Neue anmelden

    If value = VisibleUserControl.Spielfeld OrElse
        value = VisibleUserControl.SpielfeldEditor Then
        Spielfeld.PaintSpielfeld_GiveGeneralPermission(VisibleUserControls(value))
    End If