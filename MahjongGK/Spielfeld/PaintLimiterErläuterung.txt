
Erläuterungen zu dem Modul PaintLimiterModul und der Klasse PaintLimiterClass.

Windows ist nicht dafür geeignet Animationen gleichmäßig und flüssig darzustellen.
Um das zu erreichen muß man tief in die Trickkiste greifen - dazu sind diese beiden
PainterLimiter zuständig.

Der Grund für den Aufwand ist die (technisch bedingte) Unzuverlässigkeit des Timers
bei sehr kurzen Zeiten. Überlagert wird das noch davon, das das Paint Event nach dem
Befehl Me.Invalidate nicht sofort ausgelößt wird, sondern erst dann, wenn es dem
Betriebssystem passt. Die Bildschirmausgabe steht in der Rangordnung ziemlich weit
unten.

Gelößt wird das im Prinzip wie folgt:

1.) Ein Timer lößt viel zu oft das Me.Invalidate aus, im Abstand von nur einer 
    Millisekunden. Windows verarbeitet die nicht alle, verwirft die Meisten gleich.
    Aber es kommen so viele durch, daß das Maximum erreicht wird.

2.) Im Paint Event der Oberfläche, auf die gezeichnet werden soll (Also UCtlSpielfeld
    und UCtlEditor) kommen jetzt viel zu viele Paint-Events an.
    Daher wird als erstes geprüft, ob überhaupt gezeichnet werden darf:

        Private Sub UCtlSpielfeld_Paint(sender As Object, e As PaintEventArgs) Handles Me.Paint
            
            If Spielfeld.PaintLimiter.BeginPaint Then
                Spielfeld.PaintSpielfeld_Paint(frmMain.VisibleUserControl.Spielfeld, e, New Rectangle(0, 0, Width, Height), Spielfeld.PaintLimiter.TimeDifferenzFaktor)
            End If

        End Sub

3.) PaintSpielfeld wird noch der Wert PaintLimiter.TimeDifferenzFaktor mitgegeben.
    Das ist ein Faktor, der angibt um wieviel sich das Event gegenüber der Sollzeit
    verspätet (oder verfrüht) hat. Damit kann die Animation korrigiert werden,
    z.B. die Anpassung des Drehwinkels zwischen zwei Frames, sodaß der Eindruck der
    Gleichmäßigkeit entsteht. 
    Damit läßt sich nicht alles kaschieren, aber es ist deutlich besser als eine
    konventionelle Steuerung.




In frmMain ist noch etwas Verwaltungsarbeit notwendig.

Im Designer ist auf FrmMain ein TabControl zu sehen, mit je einem Reiter je Usercontrol.
Sobald das Programm läuft, verschwindet das Tabcontrol.
Die einzelnen UserControls werden über das Menue nach Bedarf in frmMain "eingehängt".

Das Einhängen geschieht in  Private Property AktVisibleUserControl As VisibleUserControl
im Setter. Hier gibt es folgenden Abschnitt:

    'Ein eventuell noch laufendes Spielfeld abschalten
    
    Spielfeld.PaintSpielfeld_CancelGeneralPermission()

    'Und das Neue anmelden

    If value = VisibleUserControl.Spielfeld OrElse
        value = VisibleUserControl.SpielfeldEditor Then
        Spielfeld.PaintSpielfeld_GiveGeneralPermission(VisibleUserControls(value))
    End If